"""
Function to parse micromeritics xls output files

@author Chris Murdock
"""

import xlrd
from itertools import product
import re
import logging

_number_regex = re.compile(r'^(-)?\d+(.|,)?\d+')

_fields = {
    'bet surface area': {
        'name': 'surface area',
        'row': 0,
        'column': 1,
        'type': 'number'
    },
    'sample:': {
        'name': 'sample',
        'row': 0,
        'column': 1,
        'type': 'string'
    },
    'sample mass': {
        'name': 'mass',
        'row': 0,
        'column': 1,
        'type': 'number'
    },
    'comments': {
        'name': 'comments',
        'row': 0,
        'column': 0,
        'type': 'string'
    },
    'analysis ads': {
        'name': 'gas',
        'row': 0,
        'column': 1,
        'type': 'string'
    },
    'analysis bath': {
        'name': 'temperature',
        'row': 0,
        'column': 1,
        'type': 'number'
    },
    'started': {
        'name': 'date',
        'row': 0,
        'column': 1,
        'type': 'string'
    },
    'isotherm tabular': {
        'type': 'isotherm report',
        'labels': {
            'Relative': 'relative',
            'Absolute': 'absolute',
            'Quantity': 'uptake',
            'Elapsed': 'time',
            'Saturation': 'saturation'
        }
    },
    'primary data': {
        'type': 'error',
        'row': 1,
        'column': 0,
        'name': 'errors'
    },
    'cell_value': {
        'header': {
            'row': 2
        },
        'datapoints': {
            'row': 3
        }
    }
}


def read_xls_report(path):
    """Parses an xls file generated by micromeritics software.

    Arguments:
    path: the location of an xls file generated by a micromeritics instrument.

    Returns: A dictionary containing report information.
    """
    workbook = xlrd.open_workbook(path, encoding_override='latin-1')
    sheet = workbook.sheet_by_index(0)
    data = {}
    errors = []
    for r, c in product(range(sheet.nrows), range(sheet.ncols)):
        cell_value = str(sheet.cell(r, c).value).lower()
        try:
            field = next(v for k, v in _fields.items() if
                         cell_value.startswith(k))
        except StopIteration:
            continue
        if field['type'] == 'number':
            val = sheet.cell(r + field['row'], c + field['column']).value
            data[field['name']] = _handle_numbers(val)
        elif field['type'] == 'string':
            val = sheet.cell(r + field['row'], c + field['column']).value
            data[field['name']] = _handle_string(val)
        elif field['type'] == 'isotherm report':
            data['pressure'] = {}
            for i, item in enumerate(_get_data_labels(sheet, r, c)):
                points = _get_datapoints(sheet, r, c + i)
                _assign_data(item, field, data, points)
        elif field['type'] == 'error':
            errors += _get_errors(sheet, r, c)
    if errors:
        data['errors'] = errors
    _check(data, path)
    return data


def _handle_numbers(val):
    """Input is a cell of type 'number'. Removes any extra information (such as
    units) to return only the number as a float.
    """
    if val:
        return float(_number_regex.search(val.replace(',', '')).group())
    else:
        return None


def _handle_string(val):
    """Input is a cell of type 'string'. Replaces Comments: and any newline
    found.
    """
    return val.replace('Comments: ', '').replace('\r\n', ' ')


def _convert_time(points):
    """Converts time points from HH:MM format to minutes."""
    minutes = []
    for point in points:
        h, m = str(point).split(':')
        minutes.append(int(h) * 60 + int(m))
    return minutes


def _get_data_labels(sheet, r, c):
    """Locates all column labels for data collected during the experiment."""
    final_column = c
    header_row = _fields['cell_value']['header']['row']
    # Abstract this sort of thing
    header = sheet.cell(r + header_row, final_column).value
    while any(header.startswith(label) for label
              in _fields['isotherm tabular']['labels']):
        final_column += 1
        header = sheet.cell(r + header_row, final_column).value
    return [sheet.cell(r + header_row, i).value for i in
            range(c, final_column)]


def _get_datapoints(sheet, r, c):
    """Returns all collected data points for a given column."""
    row = _fields['cell_value']['datapoints']['row']
    # Data can start on two different rows. Try first option and then next row.
    if sheet.cell(r + row, c).value:
        start_row = r + row
        final_row = r + row
    else:
        start_row = r + (row + 1)
        final_row = r + (row + 1)
    point = sheet.cell(final_row, c).value
    while point:
        final_row += 1
        point = sheet.cell(final_row, c).value
    return [sheet.cell(i, c).value for i in range(start_row, final_row)]


def _assign_data(item, field, data, points):
    """For each column of data collected, the data is added to the data
    dictionary in a form depending on the lebel of the column.
    """
    name = next(f for f in field['labels'] if item.startswith(f))
    if field['labels'][name] == 'time':
        data['time'] = _convert_time(points)
    elif field['labels'][name] == 'uptake':
        data['uptake'] = points
    elif field['labels'][name] in ['relative', 'absolute', 'saturation']:
        data['pressure'][field['labels'][name]] = points
    else:
        raise ValueError("Label name '{}' not recognized."
                         .format(field['labels'][name]))


def _get_errors(sheet, r, c):
    """Looks for all cells that contain errors (are below a cell
    labeled primary data).
    """
    field = _fields['primary data']
    val = sheet.cell(r + field['row'], c + field['column']).value
    if not val:
        return []
    final_row = r + field['row']
    error = sheet.cell(final_row, c + field['column']).value
    while error:
        final_row += 1
        error = sheet.cell(final_row, c + field['column']).value
    return [sheet.cell(i, c + field['column']).value
            for i in range(r + field['row'], final_row)]


def _check(data, path):
    """Checks keys in data and logs a warning if a key is empty. Also logs a
    warning for errors found in file.
    """

    if 'uptake' in data:
        empties = (k for k, v in data.items() if not v)
        for empty in empties:
            logging.info('No data collected for {} in file {}.'
                         .format(empty, path))
    if 'errors' in data:
        logging.warning('\n'.join(data['errors']))
